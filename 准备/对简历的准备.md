# 对简历的准备

## 自我介绍

您好，我叫张艺，来自武汉大学，现在是学硕，开学之后研三了。我在大三的时候作为实习生加入了现在的实验室，做了第一个项目基本状态数据库，作为前端开发完成了基础模板表单的批量管理功能，大四保研之后，我就留在这个实验室接手了武汉大学本科生教学管理系统的运维工作，研一之后这个系统因为需求变更和技术的换代进行了重做，在里面承担了大部分的工作，包括前期的需求调研、产品设计以及后面的开发等等，做了差不多五六个月。到研一下学期帮助另一个项目应急，参与了地震监测系统的前端开发工作。到年底，这个教学管理系统的web端需要进行重构，承担了项目经理，一直从筹划到完整上线，7月初刚完成了项目交接。从我经历您也能看出来，我做过的岗位都是跟着需求在编，一直都不太稳定，但经历了这么多之后，我也找找到了今后的人生方向，就是好好做一个前端。

## 项目

### 项目： 武汉大学本科生教务系统 web 端 改版

#### 采用jquery.i18n.properties实现英文版本

实现思路：给所有的静态资源加一个class,记录用户在页面上选的值，保存在cookie里。然后页面显示时读取这个值。遍历页面上有这个class的节点，读取它的name属性值，然后在property文件里找它对应的值显示出来。

期间还有一些英文太长的样式问题，通过world-break：break-all来解决的。

剩下的就主要是 样式布局的调整了。

#### 选课撮合的流程

三种类型是不一样的

1.公必课的话是实时撮合的，循环提取学生的申请课头信息，检查课程剩余人数、学生的已修学分有没有超过最大学分，有没有选过相同课程号的课程，再判断课程号是不是tiyu开头的，如果是高级要通过name去匹配有没有修过初级。最后查看学生的课程是否有冲突，没有就选课成功，并且更新学生已选学分和课程人数。



2.公选课的话是高年级优先，所以需要按照年级排序，首先先看这门课程的编码能不能选（18级的学生不可以选老生的课程，编码长度低于13位），然后处理申请表里面信息，检查学生已修学分有没有大于最大学分，课程剩余人数，学生有没有选过这门课程（同课程号），检查冲突，没有就选课成功，并且更新学生已选学分和课程人数。



3.前面两种是按照申请表去处理的，但是专业课的处理规则是按照课头去处理的，获取课头的剩余人数。如果选这门课的学生大于剩余人数就重新按照专业、年级排序，之后再依次处理，如果没有的话，就直接进入处理单个学生的循环。判断学生有没有选这门课、有没有超过当前学年对专业课总学分的要求，检查有没有冲突，如果没有，就把这门课插入课表，剩余人数-1.

### 项目：AETA多分量地震系统

### 英文版本实现

其实跟教务系统的原理是一样的，只不过不是一个文件一个data.js数据。读取在data.js里查找罢了，相当于对象数组取值。

### Esri arcgis

用require导入Esri的插件

初始化地图new Map，输入中心的经纬度。然后创建一个图层layer，再把图层加到地图上。

获取数据和坐标，然后创建graphic

<br/>

1.引申问题：

require相当于动态创建script标签，引入响应的js。

init.js里面修改路径的作用，路径是dojo.baseurl，指向存放dojo.js的文件夹，用于dojo模块管理。在require的时候通过路径找响应的模块。

2.引申问题：模块化？

require是Commonjs的规范，

用法就是一个文件module.exports{ 方法};另一个文件require(url)，直接使用这个方法。

本质上就是把要导出的对象赋值给module对象的exports属性，然后从其他文件用require方法访问这个属性。

跟ES6模块啥区别？

es6是用的export导出，export default一个文件一个，然后import 并列from URL。

commonjs输出的是一个值，es6输出的是值的引用。最大的区别还是commonjs是运行时加载，但是es6的是编译时输出接口。

### Echats

先初始化init。

然后设置标题、图标和空的坐标轴

setOption：title tooltip legend toolbox

series里面存数据和对应的名字颜色等等。 

## 问题

### c#客户端的单例模式长连接怎么做到的

我们项目的客户端是胖客户端，sql语句都是在本地拼接好执行的，只要保证每次获取后台连接都是用的同一个接口，就能保证一个客户端只有一个连接。

引申问题：如果是前后端分离的情况

多个前端共享一个后台，后台只有一个数据库连接，难以保证并发性能，所以一般采用俩劫持管理多个数据库连接。如果想要保证用户使用的数据连接一直都是同一个，可以将用户标识跟数据库连接绑定，比如说sessionid

### 热更新是怎么做的

有两个程序，一个是更新程序，一个是应用程序。每次启动其实启动是更新程序，它根据版本号去服务器上检查资源是否有更新，更新的内容是先放在一个temp文件夹下面的，全部更新完了才覆盖原来的内容。如果更新失败，就直接启动应用程序。

### 台站发请求线程池超了，要怎么处理

服务器处理不了那么多请求，目前的修改方式是换了一个线程池，到一定阈值了就拒绝，等待下次请求再处理。

祥哥说有更好的解决方案：

用消息队列来做，先把数据接收了，后面让服务器来算。根据消息每秒的加入量和服务器能处理的量，来判断多少个服务器处理。

### 消息队列服务怎么做的

直接发送到消息队列的服务器，然后写一个消费者的服务，按照消息队列的顺序，调用短信接口处理。保证收到短信接口的回复了才通知消息队列。然后消息队列删除这条消息。

### 文件服务器实现的办法

给文件做标识，然后把服务器上的地址，保存在数据库里。当要获取它时，就去数据库里取它的地址，从文件服务器上通过标识来获取。

### 服务器上的缓存

其实就是建了一个HashMap，把所有的课程数据，全部放在了Map里，如果要请求课程数据，就先去Map，看是否到时间了，如果时间过期，那么就去数据库里面查询，更新Map，并更新时间。如果没有过时就直接从Map获取数据。

这种优化只能用于不常更新的数据，因为会有实时性的问题。