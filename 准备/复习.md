<!-- TOC -->autoauto- [简历](#简历)auto    - [自我介绍](#自我介绍)auto    - [项目提问](#项目提问)auto        - [中英文的改版是如何实现的？](#中英文的改版是如何实现的)auto        - [选课撮合的规则](#选课撮合的规则)auto        - [地图描点是怎么做的？](#地图描点是怎么做的)auto        - [数据怎么显示的](#数据怎么显示的)auto        - [c#客户端的单例模式长连接怎么做到的](#c客户端的单例模式长连接怎么做到的)auto        - [热更新是怎么做的](#热更新是怎么做的)auto        - [台站发请求线程池超了，要怎么处理](#台站发请求线程池超了要怎么处理)auto        - [消息队列服务怎么做的](#消息队列服务怎么做的)auto        - [文件服务器实现的办法](#文件服务器实现的办法)auto        - [服务器上的缓存](#服务器上的缓存)auto- [HTML](#html)auto    - [Doctype有什么作用？](#doctype有什么作用)auto    - [如何区分严格模式和混杂模式？区分的意义是什么？](#如何区分严格模式和混杂模式区分的意义是什么)auto    - [为什么HTML5只需要写`<!DOCTYPE HTML>`](#为什么html5只需要写doctype-html)auto    - [meta标签用来做什么？](#meta标签用来做什么)auto    - [src和href的区别](#src和href的区别)auto    - [HTML5的新特点](#html5的新特点)auto    - [什么是shadow DOM](#什么是shadow-dom)auto    - [Canvas有什么用](#canvas有什么用)auto    - [不改变图片原始大小画到canvas上面](#不改变图片原始大小画到canvas上面)auto- [CSS基础](#css基础)auto    - [页面导入样式时，使用link和@import有什么区别？](#页面导入样式时使用link和import有什么区别)auto    - [盒子模型，CSS3的box-sizing值有哪些？](#盒子模型css3的box-sizing值有哪些)auto    - [行内元素有哪些？块级元素有哪些？空元素有哪些](#行内元素有哪些块级元素有哪些空元素有哪些)auto    - [行内元素和块级元素的区别与互换](#行内元素和块级元素的区别与互换)auto    - [inline-block、inline和block的区别？](#inline-blockinline和block的区别)auto    - [为什么img是inline还可以设置宽高？](#为什么img是inline还可以设置宽高)auto    - [CSS 中 inline 元素可以设置 padding 和 margin 吗？](#css-中-inline-元素可以设置-padding-和-margin-吗)auto    - [伪类和伪元素？](#伪类和伪元素)auto    - [CSS选择器的权重](#css选择器的权重)auto    - [外边距重叠](#外边距重叠)auto    - [层叠上下文](#层叠上下文)auto    - [说一下什么是BFC](#说一下什么是bfc)auto    - [元素隐藏方法和区别](#元素隐藏方法和区别)auto    - [`display：none`和`visibility:hidden`的区别](#displaynone和visibilityhidden的区别)auto    - [如何清除浮动](#如何清除浮动)auto    - [img和background-image的区别](#img和background-image的区别)auto    - [rgba()和opacity的区别](#rgba和opacity的区别)auto    - [outline和border的区别](#outline和border的区别)auto    - [CSS动画如何实现](#css动画如何实现)auto    - [transition、animation的区别](#transitionanimation的区别)auto- [CSS布局](#css布局)auto    - [水平居中的实现方案](#水平居中的实现方案)auto    - [垂直居中的实现方案](#垂直居中的实现方案)auto    - [垂直水平居中的实现方案](#垂直水平居中的实现方案)auto    - [两栏布局，左边固定，先加载内容区](#两栏布局左边固定先加载内容区)auto    - [三栏布局](#三栏布局)auto    - [Flex布局](#flex布局)auto- [JS基础](#js基础)auto    - [基本数据类型](#基本数据类型)auto    - [null是Object吗](#null是object吗)auto    - [原始类型与对象类型区别](#原始类型与对象类型区别)auto    - [typeof vs instanceof](#typeof-vs-instanceof)auto    - [如何判断一个对象类型是数组](#如何判断一个对象类型是数组)auto    - [==比较](#比较)auto    - [闭包、作用域链](#闭包作用域链)auto    - [原型链](#原型链)autoauto<!-- /TOC -->
# 简历

## 自我介绍

您好，我叫张艺，来自武汉大学，现在是学硕，开学之后研三了。我的研究方向是人工免疫，方向比较偏，不是主流的算法研究方向，也没有合适的算法岗，所以我就计划转开发了。

我最早接触前端是在大三的时候，来现在的实验室当实习生，做了第一个项目基本状态数据库，在这个项目里写了基础模板表单的功能。大四保研之后，就接手了我们学校的本科生教务管理系统的运维工作，一直到今年7月份，一直在这个项目组里工作。中间研一的时候，因为需求变更、技术换代进行了重做。之前是客户端的开发，到了17年的12月份的时候，web端进行了改版，我是承担了项目经理的职务。中途我们还有一个跟北京大学做的地震数据监测系统，这个系统主要是为我们研究服务的，在里面做了一个月左右的前端开发。

我的经历其实在前端这边的工作并不多，但是之前也有做过一些，感觉前端还是很有意思的，再加上最近几年的发展态势，所以我想要之后也继续在这个领域发展下去。



## 项目提问

### 中英文的改版是如何实现的？

我们是用的jquery.i18n.properties的插件来做的。

它的实现思路就是：给所有的静态资源添加一个class属性，项目里是i18n，然后把需要的进行中英文替换的HTML标签添加上name属性（这个就是我们资源文件的key）。

我们在用户进入页面后，把用户选的值，保存在cookie里。当页面显示的时候读取这个值，然后遍历页面上所有有i18n这个class的节点，按照上面的name属性，去资源文件里读取它的value值。然后把它显示出来。

当然中间会有替换成英文样式的问题，像那种很长的英文，就显示一半，鼠标移动上去再显示出来。这个用的是CSS：world-break:break-all.

剩下的就是一些样式布局的调整了。

### 选课撮合的规则

常见种类的有三类：公必、公选、专业课。

公共必修课是实时撮合的，直接提取学生的申请课头信息，检查课程剩余人数、学生的已修学分有没有超过最大学分，有没有选过相同课程号的课程，再判断课程号是不是tiyu开头的，如果是高级要通过name去匹配有没有修过初级。最后查看学生的课程是否有冲突，没有就选课成功，并且更新学生已选学分和课程人数。

公共选修课的话是高年级优先，所以需要按照年级排序，首先先看这门课程的编码能不能选（18级的学生不可以选老生的课程，编码长度低于13位），然后处理申请表里面信息：检查学生已修学分有没有大于最大学分，课程剩余人数，学生有没有选过这门课程（同课程号），检查冲突，没有就选课成功，并且更新学生已选学分和课程人数。

专业课的处理规则是按照课头去处理的，获取课头的剩余人数。如果选这门课的学生大于剩余人数就重新按照专业、年级排序，之后再依次处理，如果没有的话，就直接进入处理单个学生的循环。判断学生有没有选这门课、有没有超过当前学年对专业课总学分的要求，检查有没有冲突，如果没有，就把这门课插入课表，剩余人数-1.

### 地图描点是怎么做的？

用的一个arcgis的插件，叫Esri.

先require导入Esri的插件，然后初始化地图new Map，输入中心的经纬度。然后创建一个图层layer，再把图层加到地图上。获取数据和坐标，然后创建graphic。

require相当于动态创建script标签，引入响应的js。init.js里面修改路径的作用，路径是dojo.baseurl，指向存放dojo.js的文件夹，用于dojo模块管理。在require的时候通过路径找响应的模块。

### 数据怎么显示的

用的是插件，叫Echarts。

先初始化init。

然后设置标题、图标和空的坐标轴

setOption：title tooltip legend toolbox

series里面存数据和对应的名字颜色等等。 

### c#客户端的单例模式长连接怎么做到的

我们项目的客户端是胖客户端，sql语句都是在本地拼接好执行的，只要保证每次获取后台连接都是用的同一个接口，就能保证一个客户端只有一个连接。

引申问题：如果是前后端分离的情况

多个前端共享一个后台，后台只有一个数据库连接，难以保证并发性能，所以一般采用俩劫持管理多个数据库连接。如果想要保证用户使用的数据连接一直都是同一个，可以将用户标识跟数据库连接绑定，比如说sessionid

### 热更新是怎么做的

有两个程序，一个是更新程序，一个是应用程序。每次启动其实启动是更新程序，它根据版本号去服务器上检查资源是否有更新，更新的内容是先放在一个temp文件夹下面的，全部更新完了才覆盖原来的内容。如果更新失败，就直接启动应用程序。

### 台站发请求线程池超了，要怎么处理

服务器处理不了那么多请求，目前的修改方式是换了一个线程池，到一定阈值了就拒绝，等待下次请求再处理。

祥哥说有更好的解决方案：

用消息队列来做，先把数据接收了，后面让服务器来算。根据消息每秒的加入量和服务器能处理的量，来判断多少个服务器处理。

### 消息队列服务怎么做的

直接发送到消息队列的服务器，然后写一个消费者的服务，按照消息队列的顺序，调用短信接口处理。保证收到短信接口的回复了才通知消息队列。然后消息队列删除这条消息。

### 文件服务器实现的办法

给文件做标识，然后把服务器上的地址，保存在数据库里。当要获取它时，就去数据库里取它的地址，从文件服务器上通过标识来获取。

### 服务器上的缓存

其实就是建了一个HashMap，把所有的课程数据，全部放在了Map里，如果要请求课程数据，就先去Map，看是否到时间了，如果时间过期，那么就去数据库里面查询，更新Map，并更新时间。如果没有过时就直接从Map获取数据。

这种优化只能用于不常更新的数据，因为会有实时性的问题。

# HTML

## Doctype有什么作用？

声明文件类型定义（DTD），位于文档中最前面，作用是为了告知浏览器应该用哪种文档类型规范来解析文档。

## 如何区分严格模式和混杂模式？区分的意义是什么？

- 定义

  - 严格模式（标准模式),浏览器按照W3C标准来解析；
  - 混杂模式，向后兼容的解析方法，浏览器用自己的方式解析代码。

- 如何区分？

  用DTD来判断

  - 严格格式DTD——严格模式；
  - 有URL的过渡DTD——严格模式，没有URL的过渡DTD——混杂模式；
  - DTD不存在/格式不对——混杂模式；
  - HTML5没有严格和混杂之分

- 区分的意义
  严格模式的排版和js运行模式以浏览器支持的最高标准运行。如果只存在严格模式，那么很多旧网站站点无法工作。

## 为什么HTML5只需要写`<!DOCTYPE HTML>`

HTML5不基于SGML(标准通用标记语言)，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为。

## meta标签用来做什么？

提供给机器解读的一些元数据。页面搜索引擎优化，定义页面实用语言等等。
属性有两个

1）**http-equiv+content**

- charset(编码格式)
- expires(过期时间)
- refresh(特定时间内自动刷新跳转)
- pragma(禁止浏览器从本地计算机缓存中访问页面内容no-cache)
- widows-target(设定页面在窗口中以独立页面展示，防止被当成frame页调用)
- set-cookie(自定义cooke)、
- ontent-Type(字符集)

2）**name+content**

- keywords(关键字)
- description(主要内容)
- robots(none不被检索)
- author、generator(使用的制作软件)
- copyright
- viewport(缩放比例)

## src和href的区别

href 指向网络资源位置，建立当前文档和资源的连接，一般用于超链接

src将资源嵌入到当前文档中，在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也是如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部。

## HTML5的新特点

很多语义化的标签

- canvas js绘图

- draggable属性 可拖动

- geolocationAPI 获取用户地理位置

- audio/video 音频 视频元素

- input类型增多，color、date、datetime、datetime-local、email、month、range、search、tel、time、url、week

- 表单元素增强 

  datalist 与input配合使用规定输入域的选项列表；keygen密钥;output定义不同类的输出。

- Web存储，sessionStorge针对一个session进行数据存储，关闭浏览器创港口后清除，localStorage没有事件限制，不过它可能会因为本地时间修改失效。不过大量复杂数据结构一般用indexDB

- Web worker 页面中执行脚本时，页面状态不可响应，直到脚本完成。在后台运行，独立于其他脚本，不会影响页面的性能。（相当于多线程并发）

- SSE server-sent-event 网页自动获取来自服务器的更新。用于接收服务器发送时间通知

- WebSocket 在单个TCP连接上进行全双工通讯的协议。只需要握手一次，形成快速通道，传输数据。客户端和服务器可以直接通过TCP交换数据。获取连接之后，可以用send发送数据，用onmessage接收服务器返回的数据。

- 新API 

  History、Command、Application cache ……

## 什么是shadow DOM

Shadow DOM是浏览器的一种功能，能自动添加子元素，比如radio元素的controls，这些相关元素由浏览器生成。

## Canvas有什么用

相当于在页面上新建了一个画布，可以用JS画图。只写一些基本的。

获取DOM,创建画布 getContext('2d');

- 矩形

  fillRect(x,y,width,height) 填充

  strokeRect(x,y,width,height) 边框

  clearRect(x,y,width,height)清除指定区域

- 路径

  创建起始点，画图，闭合路径。路径绘制完成，可以描边或者填充。

  beginPath()新建路径

  closePath()闭合路径

  stroke()描边

  fill()填充

- 移动笔触

  moveTo(x,y) 移动到某点

- 绘制直线

  lineTo(x,y) 从当前位置绘制到(x,y)的一条直线

- 绘制圆

  arc(x,y,radius,startAngle,endAngle,anticlockwise) 以(x,y)为圆心，radius为半径，startAngle和endAngle以X轴为准开始结束的弧度，anticlockwise为true顺时针，false逆时针。

## 不改变图片原始大小画到canvas上面

第一种，直接在坐标上画图，如果图片大小超出了画布也不缩放

drawImage(image,x,y);

第二种，绘制开始位置，缩放位置，图片会变形

drawImage(image,x1,y1,x2,y2);

第三种，从图片的某个坐标开始截图，截取m*n的大小。然后截的图片从canvas的x1,y1画到x2,y2。

drwaImage(image,xi,yi,m,n,x1,y1,x2,y2)

# CSS基础

## 页面导入样式时，使用link和@import有什么区别？

- link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS; 
- 页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;
- @import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题; 

## 盒子模型，CSS3的box-sizing值有哪些？

盒子模型是指用来装页面上元素的矩形区域，CSS的盒子模型包括IE盒子模型和标准W3C的模型。区别在于width，IE盒子中width表示Content+padding+border。

box-sizing有三种属性，一种是content-box，一种是border-box,还有一个是从父元素继承的inherit。现在还有一个padding-box。

content-box一 宽高应用到内容框

border-box— 宽高包括了内边距和边框

padding-box—高宽包括了内边距

## 行内元素有哪些？块级元素有哪些？空元素有哪些

首先：CSS规范规定，每个元素都有display属性，确定该元素的类型，每个元素都有默认的display值，如div的display默认值为“block”，则为“块级”元素；span默认display属性值为“inline”，是“行内”元素。
（1）行内元素有：a b span img input select strong（强调的语气）
（2）块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p
（3）常见的空元素：
`<br><hr><img><input><link><meta>`
鲜为人知的是：
`<area><base><col><command><embed><keygen><param><source><track><wbr>`

## 行内元素和块级元素的区别与互换

- 区别

  - 行内元素会在一行水平方向排列，块级元素独占一行，自动填满父级元素
  - 块级元素可以包含行内元素和块级元素，行内只能包含文本和其他行内元素
  - 盒模型属性上，行内元素width height无效，pading和margin垂直方向上无效

- 互换

  display：inline/block

- inline-block元素

  既可以设置高宽，又有inline元素不换行的特性。

## inline-block、inline和block的区别？

block是块级元素，能设置宽高，margin/padding都有效前后都有换行符

inline设置宽高无效，margin在竖直方向无效，padding有效，前后无换行符

inline-block可以设置宽高，margin/padding有效，前后无换行符

## 为什么img是inline还可以设置宽高？

img是**可替换元素**，这类元素的展现效果不是由CSS来控制的。他们是一种外部对象，外观的渲染独立于CSS。内容不受当前文档的样式影响，CSS可以影响可替换元素的位置，但是不会影响到可替换元素自身的内容。（比如iframe，可能有自己的样式表，不会继承父文档的样式）
可替换元素有内置宽高，性质同设置了inline-block一样。

## CSS 中 inline 元素可以设置 padding 和 margin 吗？

width、height可以设置，但是没有用。

padding 左右是有用的，上下么有用。

margin 上下左右都有用。

## 伪类和伪元素？

**伪类可以理解为是一种状态，而伪元素则代表一些实实在在存在的元素，但是它们都是抽象刻画的，游离于标准文档之外。**

伪类存在的意义是为了通过选择器，格式化dom树以外的信息（:visited,:link），以及**不能被常规CSS选择器获取到的信息**（比如说获取第一个子元素，常规css选择器不行,可以用：first-child）。

伪类常用的有`first-child、last-child、nth-child、first-of-type`(父元素第一个特定的子元素)、`last-of-type、nth-of-type、lang、focus`、lvha（a标签四个）

伪元素可以**创建一些文档语言无法创建的虚拟元素**，比如文档语言没有一种机制可以描述元素内容第一个字母或者第一行，但是伪元素可以`::first-letter,::first-line`。同时伪元素还可以创建文档中不存在的内容比如说`::after,::before`。

伪元素主要有：

`::after,::before,::first-letter,::first-line,::selection   `

## CSS选择器的权重

- ！important 权重无限大
- 内联样式 写在html标签里的
- 类 伪类 和属性选择器
- 标签选择器和伪元素选择器 div p:after
- 通配符、子选择器、相邻选择器
- 继承的样式没有权值

## 外边距重叠

多个相邻(兄弟或父子) 普通流的块级元素在垂直方向的margin会重叠

- 两个相邻的外边距都为正数，折叠结果是较大的值
- 两个相邻的外边距为负数，折叠结果是绝对值较大的值
- 两个相邻外边距为一正一负，折叠结果是他们的和

## 层叠上下文

层叠上线文就是结界，其中的元素如果跟层叠上下文之外的元素发生层叠，就比较他们的层叠水平高低来显示。

创建的方法：postion为relative、absolute、fixed的元素设置z-index

顺序是：底层的border、background，负值z-index，块级盒子，浮动盒子，内联盒子，z-index：auto, 正z-index

## 说一下什么是BFC

BFC是块级格式化范围，决定了元素如何对其内容进行定位，以及和其他元素的关系和相互作用。可以理解为它就是个**独立的容器，容器里面的布局与外面互不影响**。

触发规则：

- 根元素
- 浮动元素
- postion：absolute 或 fixed
- display：inline-block，table-cell，table-caption，flex，inline-flex
- overflow：不为visible

规则：垂直方向一个一个放；距离由margin决定，同一个bfc里面相邻会重叠；不会和浮动元素重叠；计算高度时浮动子元素也计算；容器内与容器外互不影响。

主要用途：清除浮动 防止margin重叠

## 元素隐藏方法和区别

- display：none元素不可见，不占据空间，资源会加载，DOM可以访问
- visibility:hidden元素不可见，不能点击，但占据空间，资源会加载，可以使用。
- opacity：0 元素不可见、可以点击，占据空间，可以使用。（不占据的话再加一个position absolute)(不能点击不占据空间 postion absolute+z-index:-1)(不能点击、占据空间 postion relative z-index:-1)

## `display：none`和`visibility:hidden`的区别

- display：none元素不占据空间，visibility:hidden空间保留
- display：none会影响opacity过渡效果
- display会产生重绘回流，visibility:hidden只重绘
- display：none节点和子孙节点都不见，visibility:hidden的子孙节点可以设置visibility:visible显示。
- visibility:hidden不会影响计数器计数（ol标签）

## 如何清除浮动

当元素设置float浮动后，该元素会脱离文档并向左向右浮动，直到碰到父元素或者另一个浮动元素，浮动元素会造成父元素高度塌陷，所以设置完浮动之后需要进行清除浮动

解决方案：

- BFC

  给父容器加上overflow:hidden，加上之后，形成BFC，需要计算超出的大小来隐藏，所以父容器会撑开放入子元素，同时计算浮动的子元素。

  缺点：但是一旦子元素大小超过父容器大小就会显示异常。

- 使用带有clear属性的空元素

  在浮动元素后面添加一个不浮动的空元素，父容器必须考虑浮动子元素的位置，子元素出现在浮动元素后面，所以显示出来就正常了。

  同时要给空元素加上:```style="clear:both"```

  缺点：需要添加额外的html标签，这违背了语义网的原则

- 使用伪元素::after

  它父容器尾部自动创建一个子元素，原理和空元素一样，可以把它设置为height：0不显示，clear：both display:block，保证空白字符不浮动区块。
  (但是：after不支持IE6，只需要添加上zoom：1,这个是激活父元素的haslayout属性，让父元素拥有自己的布局）

  ```css
  .clearifx::after{
      content:'';
      height:0;
      clear:both;
      display:block;
  }
  .clear{
      zoom:1;
  }
  ```

## img和background-image的区别

- 解析机制：img属于html标签，background-img属于css。img先解析
- SEO：img标签有一个alt 属性可以指定图像的替代文本，有利于SEO，并且在图片加载失败时有利于阅读
- 语义化角度：img语义更加明确

## rgba()和opacity的区别

- opacity作用于元素及元素中所有的内容（包括文字、图片） 有继承性
- rgba()只用于元素的颜色及背景色
- 当opacity属性的值应用于某个元素上时，把这个元素和它内容当作一个整体来看待，即使这个值没有被子元素继承。因此一个元素和它包含的元素都会有与元素背景相同的透明度，哪怕父子元素由不同的opacity的值。

## outline和border的区别

- outline轮廓是绘制于元素周围的一条线，位于边框边缘的外围，可以起到突出元素的作用
- outline的效果将随元素的focus而自动出现，相应的由blur自动消失，这些都是浏览器的默认行为，不需要js配合css来控制
- outline不占据空间，不会像border那样影响元素的尺寸或者位置。

## CSS动画如何实现

创建动画序列，需要animation属性或其子属性，属性允许配置动画时间、时长和动画细节。

动画的实际表现由@keyframes 规则实现

transtion也可以实现动画，但强调过渡，是元素的一个或多个属性变化时产生的过渡效果，同一个元素通过两个不同的途径获取样式，而第二个途径当某种改变发生时（如：hover)才能获取样式，这样就会产生过渡动画。

## transition、animation的区别

animation和transition大部分属性相同，都是随时间改变元素的属性值，区别是transition需要触发一个事件才能改变属性；animation不需要触发任何事件随时间改变属性。transition为2帧，从from……to ，animation可以一帧一帧的。

# CSS布局

## 水平居中的实现方案

- 利用块级元素撑满父元素的特点，如果宽度已定，左右margin auto就可以平分剩余空间
- 利用行内块居中： 把父级元素设置为text-align=center，之后子元素的display设置为inline-block
- 绝对定位：postion ：absolute，之后left 50%
- flex: 父元素**display:flex justify-content：center**

## 垂直居中的实现方案

- 元素无高度

  利用内边距，让块级文字包裹在padding中，实现垂直居中。

- 父元素高度确定的单行文本：

  使用行高的特性：height=line-height即可。

- 父元素高度确定的多行文本：

  利用vertical-align（只能内联元素）如果是div，可以设置为table和table-cell。

  ```css
  display：table-cell;
  vertical-align:center;
  ```

- 父元素高度未知：

  绝对定位，设置top 50%

  ```css
  parent{
      position:relative;
  }
  child{
      position:absolute;
      top:50%;
      transform:translateY(-50%);
  }
  ```

  如果子元素有高度

  ```css
  child{
      position:absolute;
      top:50%;
      height=Hpx;
      margin-top:(H/2)px;
  }
  ```

- 父元素高度已知

  ```css
  parent{
      height:Hpx;
  }
  child{
      position:relative;
      top:50%;
      transform:translateY(-50%);
  }
  ```

- flex方法

  ```css
  disply:flex;
  align-items:center;
  ```

## 垂直水平居中的实现方案

- 居中元素的宽高已知

  - 利用绝对定位和margin

  ```css
  parent{
      position:relative;
  }
  child{
      position:absolute;
      top:50%;
      left:50%;
      margin-top:(-H/2)px;
      margin-left:(-W/2)px;
  }
  ```

  - absolute+margin:auto

  ```css
  child{
      width:50px;
      height:50px;
      position:absolute;
      top:0;
      left:0;
      right:0;
      bottom:0;
      margin:auto;
  }
  ```

  - 用calu计算

  ```css
  child{
      position:absolute;
      top:calc(50%-50px);
      left:calc(50%-50px);
  }
  ```

- 垂直居中的元素宽高未知

  - transform的translate方法

  ```css
  child{
      position:absolute;
      top:50%;
      left:50%;
      transform:translate(-50%,-50%);
  }
  ```

  - flex布局

  ```css
  child{
      display:flex;
      align-items:center;
      justify-content:center;
  }
  ```

## 两栏布局，左边固定，先加载内容区

- float。两个div。左边float:left，width:200 px，右边 margin-left=width。
- 绝对定位。两个div。左边absolute或者fixed 右边margin-left=width
- table布局。三个div，父元素display：table，子元素display table-cell width，右边自适应
- flex布局。三个div,父元素display flex; 子元素flex:1

## 三栏布局

- 浮动布局 float:left right，中间根据两边的width设置margin(要加两边的border)

- 绝对定位 父元素 relative，左右leftright各为0，absolute，中间元素设置margin

- BFC 左右float，中间overflow：hidden

- Flex 写法左中右，父元素display:flex，中间区域flex:1

- table布局，写法左中右，父元素display：table，三个元素table-cell

- 圣杯布局 写法中左右，中间width100%，左边margin-left -100%，右边margin-left= -width（-100px); 然后防遮住中间，左右相对定位relative。

- 双飞翼  中间再包裹一层，左，右。中间父元素 float left，width：100%。

  中间子元素 margin left right 左右的width。 左右float,左边margin-left -100%，右边margin-left -width

## Flex布局

Flex是弹性布局，用来为盒装模型提供最大的灵活性。布局的传统解决方案基于盒装模型，依赖display、position和float属性。**任何一个容器都可以指定为 Flex 布局**。

注意：**设置为 Flex 布局后，子元素的 float 、clear 和 vertical-align 属性将失效。**

属性分为容器属性和元素属性：

- 容器属性包括

  - flex-direaction:决定主轴方向

  ```css
  .box{
      flex-direaction:row|row-reverse|column|column-reverse;
  }
  ```

  - flex-wrap:决定了如何换行

  ```css
  .box{
      flex-wrap:nowrap|wrap|wrap-reverse;
      /*不换行|换行第一行在上|换行第一行在下*/
  }
  ```

  - flex-flow:前面两个的简写

  ```css
  .box{
        flex-flow:<flex-direction>||<flex-wrap>;
    }
  ```

  - justify-content：水平轴对齐方式

  ```css
  .box{
        justify-content:flex-start|flex-end|center|space-between|space-around;    
    }
  ```

  - align-items: 垂直轴对齐方式

  ```css
  .box{
      align-items:flex-start|flex-end|center|space-between|space-around;
  }
  ```

- 元素属性align-content

  - order 定义项目的排序顺序，越小越靠前
  - flex-grow 放大比列，默认是0，即使存在空间也不会放大，1是说等分剩余空间
  - flex-shrink 缩小比例，当空间不够的情况下，会等比缩小为0不缩小，为1等比缩小
  - flex-basis 定义分配多余空间时，项目占据的控件
  - flex 上面三个属性的缩写，默认是0 1 auto。后两个属性可选。
  - align-self 允许单个与其他不一样的对齐方式，可以覆盖align-items属性，默认是auto表示继承。

# JS基础

## 基本数据类型

6种，boolean，number，string，undefined，null，symbol

## null是Object吗

虽然 typeof null会输出 object，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，`000` 开头代表是对象，然而 `null` 表示为全零，所以将它错误的判断为 `object` 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。

## 原始类型与对象类型区别

对象类型和原始类型不同的是，原始类型存储的是值，对象类型存储的是地址。

当创建了一个对象类型的时候，计算机会在内存中帮我们开辟一个空间来存放值，但是我们需要找到这个空间，这个空间会拥有一个地址（指针）。

## typeof vs instanceof

typeof对于原始类型来说，除null会显示成object，其余都可以显示正确的类型typeof 对于对象来说，除了函数都会显示 object，所以说typeof并不能准确判断变量到底是什么类型。

如果我们想判断一个对象的正确类型，这时候可以考虑使用 instanceof，因为内部机制是通过原型链来判断的。

## 如何判断一个对象类型是数组

- 根据构造函数来判断 xxx instanceof Array 
- 根据class属性判断 Object.prototype.toString.call(obj)==='[object Array]'
- 直接用isArray判断

## ==比较

- Boolean，number，string三类比较的时候把值转换成数字，在看转换结果是否相等。证明：（'1'==true) 是真 （'abc'==true）是假。
- undefined 参与比较，换成了NaN,所以其他三个类型跟它比较都是false，跟null类型比较的时候是true。（NaN==NaN)是假
- null参与比较，被当成对象，因为null没有valueof和toString，除了undefined谁跟他比较都是false。
- 值类型与对象比较：先调用对象valueof  如果仍返回对象，调用tostring，如果还是没有就不等。

## 闭包、作用域链

- 闭包
  - 定义：闭包就是能够读取其他函数内部变量的函数，其实就是利用了作用域链向上查找的特点。
  - 作用：读取函数内部变量，让这些变量的值一直保持在内存中。

- 作用域链
  - 作用域链针对函数作用域来说的，比如创建了一个函数，函数里面又包含了一个函数，那么就会有全局作用域、函数1的作用域、函数2的作用域。
  - 查找规范：先在自己的变量范围中找，如果找不到就沿着作用域往上找。

## 原型链

在js中，每个函数都有prototype属性，这个属性值是一个对象，同时它带有constructor属性，指向这个构造函数。

通过new可以创建一个函数的实例，每个实例都有`_proto_`属性，指向构造函数的prototype对象。

当我们在一个对象或者方法获取某个值的时候，会先查找实例上是否存在这个值，如果没有的话，就在原型里查找。