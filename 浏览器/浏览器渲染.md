# 浏览器渲染

执行渲染有一个渲染引擎。其在不同的浏览器中也不是都相同的，比如在 Firefox 中叫做 **Gecko**，在 Chrome 和 Safari 中都是基于 **WebKit** 开发的。

说明：以下内容只针对**WebKit**的渲染引擎。

那么浏览器如何进行渲染的呢？

首先：

## 接收到HTML文件==>转化为DOM树

在网络中传输的启示是0、1这些字节数据，当浏览器接收到这些字节数据后，会将它们拼接成字符串（写的代码）。

当数据转换为字符串之后，浏览器会将字符串通过词法分析转换为标记（token），这一过程在词法分析中叫做**标记化**（tokenization）。标记还是字符串，是构成代码的**最小单位**。这一过程会将代码分拆成一块块，并给这些内容打上标记，便于理解这些最小单位的代码是什么意思。

当结束标记化后，这些标记会紧接着转换为 Node，最后这些 Node 会根据不同 Node 之前的联系构建为一颗 DOM 树。

所以浏览器从网络中接收到HTML文件后会进行如下操作：

**字节数据==> 字符串==>Token==>Node==>DOM**



当然，在解析 HTML 文件的时候，浏览器还会遇到 CSS 和 JS 文件，这时候浏览器也会去下载并解析这些文件。接下来：

## 将CSS文件转换为CSSOM树

转换 CSS 到 CSSOM 树的过程和上面的过程是极其类似的

**字节数据==> 字符串==>Token==>Node==>CSSOM**

在这一过程中，浏览器会确定下每一个节点的**样式**到底是什么，并且这一过程其实是**很消耗资源**的。因为样式你可以自行设置给某个节点，也可以通过继承获得。在这一过程中，浏览器得**递归** CSSOM 树，然后确定具体的元素到底是什么样式。

为什么很消耗资源呢？

举个简单的例子

```css
cpan{
    color:red;
}
span>a>span{
    color:red;
}
```

就两种设置，第一种浏览器只需要遍历所有span标签后设置颜色就可以了，但是第二种的话，就需要先找到所有span标签，然后再找到span上有a标签的，最后再去找a里面有span的，然后再上色。

这是个递归的过程，非常耗时，所以应该**避免写这种过于具体的CSS选择器**。对于html来说，也应该尽量少的添加一个没有意义的标签，保证层级扁平化。



得到了两个树之后，就需要把两颗树组合成渲染树：

## 生成渲染树

![img](https://github.com/YiiChitty/FrontEndLearning/blob/master/img/Render_01.jpg)

在这一过程中，不是简单的将两者合并就行了。渲染树只会包括**需要显示的节点**和这些节点的样式信息。

比如说，如果某个节点是 `display: none` 的，那么就不会在渲染树中显示。

当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流），然后调用 GPU 绘制，合成图层，显示在屏幕上。



## 反思几个问题

知晓了浏览器的渲染原理，现在来反思几个问题：

**为什么操作DOM性能很差？**

因为 DOM 是属于渲染引擎中的东西，而 JS 又是 JS 引擎中的东西。当我们通过 JS 操作 DOM 的时候，其实这个操作涉及到了两个线程之间的通信，那么势必会带来一些性能上的损耗。

**操作 DOM 次数一多，也就等同于一直在进行线程之间的通信，并且操作 DOM 可能还会带来重绘回流的情况，所以也就导致了性能上的问题**。



**什么情况下会阻塞渲染**

1.首先渲染的前提是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染。

所以如果你想渲染的越快，你越应该**降低一开始需要渲染的文件大小**，并且做到**HTML扁平层级，优化CSS选择器**。

2.然后当浏览器在解析到 `script` 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。

所以，如果想首屏渲染的越快，就越**不应该在首屏就加载 JS 文件**，这也是都建议将 `script` 标签放在 `body` 标签底部的原因。

当然也不必一杆子打全船，可以有替换方案可以给script标签添加上defer 和 async属性。

> 当 script标签加上 `defer` 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 `script` 标签放在任意位置。
>
> 对于没有任何依赖的 JS 文件可以加上 `async` 属性，表示 JS 文件下载和解析不会阻塞渲染。



## 重绘和回流？？

这个是我在看别人面经时看到的东西，之前也不太清楚，今天看了几篇博客添加上的。

首先明确一下两者的概念：

- 重绘是当节点需要更改外观而不会影响布局的，比如改变 `color` 就叫称为重绘
- 回流是布局或者几何属性需要改变就称为回流。

所以说，回流**必定**会发生重绘，重绘**不一定**会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。



以下几个动作可能会**导致性能问题**

- 改变 window大小
- 改变字体
- 添加或删除样式
- 文字改变
- 定位或者浮动
- 盒模型



看一下这篇内容：[HTML文档](https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model)

**重绘和回流其实和 Eventloop 有关的！！**

整理一下内容：

> 1. 当 Eventloop 执行完 Microtasks 后，会判断 `document` 是否需要更新，因为浏览器是 60Hz 的刷新率，每 16.6ms 才会更新一次。
> 2. 然后判断是否有 `resize` 或者 `scroll` 事件，有的话会去触发事件，所以 `resize` 和 `scroll` 事件也是至少 16ms 才会触发一次，并且自带节流功能。
> 3. 判断是否触发了 media query
> 4. 更新动画并且发送事件
> 5. 判断是否有全屏操作事件
> 6. 执行 `requestAnimationFrame` 回调
> 7. 执行 `IntersectionObserver` 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好
> 8. 更新界面
> 9. 以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 `requestIdleCallback` 回调。



有点云里雾里……不过没关系，虽然目前不太明白，但是至少我们知道了这肯定是影响性能问题的。所以，得知道怎么减少重绘和回流！

以下是一些方案：

- 使用 `transform` 替代 `top`

- 使用 `visibility` 替换 `display: none` ，因为前者只会引起重绘，后者会引发回流（改变了布局）

- 不使用 `table` 布局，可能很小的一个小改动会造成整个 `table` 的重新布局

- CSS选择符从右往左匹配查找，避免节点层级过多

- 将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点。（will-change属性或者video,iframe标签等）

- 节点属性不要放在一个循环里当循环变量

  ```javascript
  //每次都要去取正确的值才行
  for(let i=0;i<100;i++){
      console.log(document.querySeletor('.test').style.offsetTop);
  }
  ```

  

## 面试题

### 1.插入几万个 DOM，如何实现页面不卡顿？

解决问题的重点应该是如何分批次部分渲染 DOM。

思路1 是通过 `requestAnimationFrame` 的方式去循环的插入 DOM；

思路2 是通过虚拟滚动。

**这种技术的原理就是只渲染可视区域内的内容，非可见区域的那就完全不渲染了，当用户在滚动的时候就实时去替换渲染的内容。**

即使列表很长，但是渲染的 DOM 元素永远只有那么几个，当我们滚动页面的时候就会实时去更新 DOM。

这个思路的解决方案可以戳[react-virtualized](https://github.com/bvaughn/react-virtualized)

### 2.在不考虑缓存和优化网络协议的前提下，可以通过哪些方式来最快的渲染页面?

这个问题的，其实在了解渲染的过程之后，解决方案已经不言而喻了，无非就是减少生成渲染树的时间了。那么回顾下渲染树是怎么生成的呢：DOM+CSSOM。

所以答案如下：

1. 从文件大小考虑
2. 从 `script` 标签使用上来考虑 async和differ
3. 从需要下载的内容是否需要在首屏使用上来考虑
4. 最后就是从 CSS、HTML 的代码书写上来考虑了



## 总结

这个部分还是挺重要的，如何写出高质量代码，理解这些东西是非常有必要的。

感觉这个方面其实还有很多东西可以学习，搜罗了一些大佬的相关博客，放在后面，供后面慢慢学习：

[深入浅出浏览器渲染原理 ](https://github.com/ljianshu/Blog/issues/51)
[DOM操作成本到底高在哪儿？](https://segmentfault.com/a/1190000014070240)
[JS 一定要放在 Body 的最底部么？聊聊浏览器的渲染机制](https://segmentfault.com/a/1190000004292479)
[Web图片资源的加载与渲染时机](https://segmentfault.com/a/1190000010032501)
[渲染性能](https://github.com/sundway/blog/issues/2)
[浏览器的渲染：过程与原理](https://zhuanlan.zhihu.com/p/29418126)