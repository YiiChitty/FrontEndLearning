## 虚拟DOM真的能提升性能吗？

**1.前言**

这个疑问是从拼多多一面被问到的一个问题引申出来的。  


当时老哥问我说你觉得为什么现在大家都不用jQuery了，都换框架开发了？

我当时下意识就想到了操作Dom性能很差的特点。我说因为 DOM 是属于渲染引擎中的东西，而 JS 又是 JS 引擎中的东西。当我们通过 JS 操作 DOM 的时候，其实这个操作涉及到了两个线程之间的通信，那么势必会带来一些性能上的损耗。操作 DOM 次数一多，也就等同于一直在进行线程之间的通信，并且操作 DOM 可能还会带来重绘回流的情况，所以也就导致了性能上的问题。  


到这里为止，我觉得我应该都没说错……后面我说虚拟DOM可能会比较好，是因为没有这个通讯时间。我说换这个应该是性能更好吧。当时老哥笑了一下，所以我觉得我多半是回答错了。后来老哥说，换框架主要原因是因为开发效率高。  



我的确没有用过框架，处于好奇，我决定深入对它了解一下，按理说应该是可以提升性能的呀……

那么**虚拟DOM真的能提升性能吗**？？



依旧是为了读者的方便，这里先说结论：

使用虚拟 DOM，**在DOM 阶段操作少了通讯的确是变高效了，但代价是在 JS 阶段需要完成额外的工作**（diff计算），这项额外的工作是需要耗时的！

虚拟DOM**并不是说比原生DOM API的操作快，而是说不管数据怎么变化，都可以以最小的代价来进行更新 DOM**。在每个点上，其实用手工的原生方法会比diff好很多。比如说仅仅是修改了一个属性，需要整体重绘吗？显然这不是虚拟DOM提出来的意义。框架的意义在于掩盖底层的 DOM 操作，用更声明式的方式来描述，从而让代码更容易维护。



好了，结论说完了，如果你还有兴趣，可以继续往下阅读。

**2.虚拟DOM**

在解决这个问题之前，需要先了解一下虚拟DOM，只有真正了解了才能知道到底能不能提升性能。

如我前言的回答所说，DOM操作问题就是在于通信，所以很多性能优化都是在尽可能地减少DOM操作次数。



虚拟DOM直接用JS实现了一个DOM树，组件的HTML结构并不会直接生成DOM，而是映射生成虚拟的js DOM。在其上面用diff算法找出最小变更，再把这些变更写入到实际的DOM中。这个虚拟DOM以js结构的形式存在，计算性能比较好，而且由于减少了实际操作DOM的次数，从理论上来说，性能应该会有很大的提升。

用传统的源生api或jQuery去操作DOM时，浏览器会从构建DOM树开始从头到尾执行一遍流程。

比如一次操作时，需要更新10个DOM节点，理想状态是一次性构建完DOM树，再执行后续操作。但浏览器没这么智能，收到第一个更新DOM请求后，并不知道后续还有9次更新操作，因此会马上执行流程，最终执行10次流程。显然，计算DOM节点的坐标值等都是白白浪费性能，可能这次计算完，紧接着的下一个DOM更新请求，这个节点的坐标值就变了，前面的一次计算是无用功。



虚拟DOM就是为了解决这个浏览器性能问题而被设计出来的。例如前面的例子，假如一次操作中有10次更新DOM的动作，虚拟DOM不会立即操作DOM，而是将这10次更新的diff内容保存到本地的一个js对象中，最终将这个js对象一次性attach到DOM树上，通知浏览器去执行绘制工作，这样可以避免大量的无谓的计算量。（嗯？似乎跟标记回收很像嘛，先把变得找出来，然后一次性改完。）



**3.Diff算法**

两棵树完全比较的时间复杂度为O(n^3)，不过Diff算法是O(n),它是采用的平层比较。

需要考虑下面四种情况：

1. 节点类型变更

   直接Replace，将旧节点卸载，装载新节点。旧节点包括下面的子节点都将被卸载，如果新节点和旧节点仅仅是类型不同，但下面的所有子节点都一样时，这样做显得效率不高，但为了避免O(n^3)的时间复杂度，这样做是值得的。

2. 仅属性或者属性值变了

   PROPS。不会卸载和装载，而是执行节点更新。

3. 文本改变

   TEXT。直接修改文字内容

4. 移动、增加、删除子节点

   REORDER。比如在ABCD插入一个节点E，代码只需要$(B).after(F)。

   但其实内部是这样，

   在JSX里为数组或枚举型元素增加上key后，能根据key直接找到具体的位置进行操作。 

在执行完diff算法之后深度遍历DOM把diff的结果更新进去就好了。



**4.在虚拟DOM之前都用啥？**

此前更新DOM树，一般是两种做法，一种是字符串拼接，另一种是用DOM对象。

举个栗子：

字符串拼接：

```js
const userList = document.getElementById("user-list");

const html = users.map(function (user) {  
return `<div id="${user.id}" class=”user”>
<h2 class="header">${user.firstName}${user.lastName}</h2>
<p class="email"><a href=”mailto:${user.email}”>EMAIL</a></p>    <p class="avg-grade">Average grade: ${user.avgGrade}</p>      <p class="enrolled">Enrolled: ${user.enrolled}</p>    
</div>  `
}).join("");

userList.innerHTML = html;
```

Dom对象

```js
const userList = document.getElementById(“user-list”);

const frag= document.createDocumentFragment();
users.forEach(function(user){   
    const div = document.createElement("div");   
    div.id = user.id;   
    div.className ="user";   
    const header = document.createElement("h2");   
    header.className ="header";   
    header.appendChild(document.createTextNode(`$ {user.firstName} $ {user.lastName}`));
    frag.appendChild(div);                                   });
                                                                                                                               userList.innerHTML ="";
userList.appendChild（frag）;
```

看起来代码真的很冗长，虚拟dom似乎能解决这种冗长的代码问题。

那么性能上呢？

**5.性能真的好吗？**

用户界面的更改通过 DOM 操作发生。

这个过程分为两个阶段：

1. JS 部分：定义 JavaScript 世界中的变化
2. DOM 部分：使用 DOM API 函数和属性执行更改

性能是根据整个过程的速度来衡量的。



创建和更新 DOM 树的整个过程分为两个阶段。使用虚拟 DOM，DOM 阶段的确变高效了。但代价是在 JS 阶段完成的额外工作，这项额外的工作叫diff，会有损耗。(**不要以为 js 计算就不花费代价**)



虚拟 DOM 只是提供了一个更方便的 API 来创建 UI。基本思维模式是每次有变动就整个重新渲染整个应用。抛开 Virtual DOM，简单来想就是直接重置 innerHTML。



其实在一个大型列表所有数据都变了的情况下，“重置 innerHTML ”其实是一个还算合理的操作… 但真正的问题是在 “全部重新渲染” 的思维模式下，即使只有一行数据变了，它也需要重置整个 innerHTML，这时候显然就有大量的浪费。



所以 ，**虚拟DOM并不是说比原生DOM API快，而是说不管数据怎么变化，都可以以最小的代价来进行更新 DOM**。 方法就是在内存里面用新数据刷新一个虚拟 DOM 树，然后新旧 DOM 进行比较，找出差异，再更新到 DOM 树上。（diff算法）



虽然说 diff 算法号称算法复杂度 O(n) 可以得到最小操作结果，但实际上 DOM 树很大的时候，遍历两棵树进行各种对比还是有性能损耗的。特别是我在顶层 setState 一个简单的数据，要整棵树 walk 一遍，而真实中我可以一句 jQuery 就搞定，所以后来就有了 `shouldComponentUpdate` 这种东西。



框架的意义在于为你掩盖底层的 DOM 操作，让你用更声明式的方式来描述你的目的，从而让你的代码更容易维护。没有任何框架可以比纯手动的优化 DOM 操作更快，因为框架的 DOM 操作层需要应对任何上层 API 可能产生的操作，它的实现必须是普适的。



针对每一个点，都可以写出比任何框架更快的手动优化，但是那有什么意义呢？在构建一个实际应用的时候，你难道为每一个地方都去做手动优化吗？出于可维护性的考虑，这显然不可能。框架给予的保证是，在不需要手动优化的情况下，依然可以提供过得去的性能。

<br/>

最后，还是要分享一个好东西：

[深度剖析：如何实现一个 Virtual DOM 算法](https://github.com/livoras/blog/issues/13)

<br/>

<br/>
这篇博客写到一半的时候收到了一面通过的消息，感觉受到了鼓舞。

越努力，越幸运。

要加油鸭。

——2019.08.08
