# http

http分为三部分：请求行、首部、实体（内容）

请求行包括了 请求方法 + URL + 协议版本

首部分为 请求首部、响应首部（有一些共用的）

实体就是报文的内容

![img](https://camo.githubusercontent.com/642fea29bb3fc75ebd452f54d800226d28a32ef2/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313436313337392d653237653231353936323161363032302e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f3839372f666f726d61742f77656270)

![img](https://camo.githubusercontent.com/c1467010b2a046275b43b01cb8737fe707873c77/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313436313337392d393663363066646532633366633139632e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f3632392f666f726d61742f77656270)

## 1.Post和Get有什么区别？

从用法上说，Post一般用于无副作用、幂等的场景；Post多用于有副作用、不幂等的情况。
> 冥等的定义：发送M和N次请求，服务器上资源状态一致。比如说，注册10个账号和11个账号是不冥等的，对文章进行了10次11次修改是幂等的，因为前者多了一个账号（资源），后者是更新同一个资源。
>   
> 副作用的定义：副作用是指对服务器上资源做改变。比如搜索是无副作用的，但更新是有副作用的。

从本质上说，Post和Get都取决于http，使用哪个方法与应用层传输没有必然的联系。HTTP没有要求，如果是POST，数据就要放在BODY中。也没有要求GET，数据（参数）就一定要放在URL中而不能放在BODY中。

细节上有一些区别：

Get能请求缓存，但是Post不可以  
Post支持更多编码类型  
Get回退无害，Post会再次提交  
Get能被保存为书签，Post不可以  
由于浏览器Url有限制，所以Get的长度受限，但Post不受限（因为都在Body里）



如果想有更多了解，可以参考：

1. [GET和POST：辩证看100 continue，以及最根本区别](https://github.com/amandakelake/blog/issues/20)
2. [99%的人都理解错了HTTP中GET与POST的区别](https://zhuanlan.zhihu.com/p/22536382)
3. [听说『99% 的人都理解错了 HTTP 中 GET 与 POST 的区别』？？](https://zhuanlan.zhihu.com/p/25028045)
4. W3C对比:[HTTP 方法：GET 对比 POST](http://www.w3school.com.cn/tags/html_ref_httpmethods.asp)

## 2.http

### 2.1 http首部

#### 2.1.1 常用通用首部

**cache-control** ： 控制缓存行为

**connection** ： 连接的性质，比如keep-alive

**user-Agent**  ：用户信息

**Date** ：报文创建时间

##### http请求中connection=keep-alive的意义在哪里

HTTP 是基于 TCP 的，每一个 HTTP 请求都需要进行三次握手。如果一个页面对某一个域名有多个请求，就会进行频繁的建立连接和断开连接。所以HTTP 1.0 中出现了`Connection: keep-alive`，用于建立长连接。Keep-Alive 模式更加高效，因为避免了连接建立和释放的开销。但是，长时间的TCP连接容易导致系统资源无效占用，配置不当的keep-alive有时比重复利用连接带来的损失还更大。所以，正确设置keep-alive timeout时间非常重要。

##### http请求中cache-control有哪些参数可以设置

**Public** :表示任何缓存都可以缓存响应

**private** :表示响应仅供单个用户使用，不得由共享高速缓存存储。私有缓存可以存储响应。

**no-cache** : 强制缓存在发布缓存副本之前将请求提交到源服务器以进行验证。

**no-store**: 缓存不应存储有关客户端请求或服务器响应的任何内容。

还有一些关于到期时间、重新验证加载的，具体可以参看[MDN文档](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control)

#### 2.1.2 常用请求首部

**Referrer Policy** : 表示来源的（浏览器所访问的前一个页面）,可以用于辅助检测crsf攻击，一般浏览器的默认值是**no-referrer-when-downgrade**，意思是https降级http的时候不传原地址。（[完整说明看MDN文档](https://developer.mozilla.org/zh-TW/docs/Web/HTTP/Headers/Referrer-Policy)）

**Accept** : 能正确接收的媒体类型

**Accept-XX**(Accept-Charset/Accept-Encoding/Accept-Language):能正确接收的xx

**Expect** :期待服务端的指定行文

**If-Match** :两端资源标记比较

**If-Modified-Since** : 比较时间 未修改返回304 Not Modified

**If-None-Match** :比较标记 未修改返回304 Not Modified

#### 2.1.3 常用响应首部

**Location** : 重定向到某个location

**Server** : 服务器名字

**Age** :响应存在时间

**Accept-Ranges** ：可以接受的范围类型

#### 2.1.4 常用实体首部

**Content-Type**：内容媒体类型

**Expires** ：内容过期时间

**Last_modified** ：最后修改时间

**Allow**：资源正确请求方式

**Content-XXX** ：Encoding编码格式 Language使用的语言 Lengthrequest body 长度MD5加密格式的内容 MD5检验值等

### 2.2 状态码

#### 1XX: 通知

**100 Continue** 客户端应重新发请求

**101 Switching Protocols** 改用协议 http换到https或者http1.1换到2.0之类

#### 2XX：成功

**200 OK** 操作成功

**201 Created**按照客户端请求创建了一个新资源

**202 Accepted** 请求无法或不被实时处理

**204 No Content** 请求成功，但是报文不含实体的主体部分

>  No Content可能的情况：
>  1.服务器拒绝请求返回 
>  2.Get资源存在但表示是空的 
>  服务器通过这个响应代码告诉客户端：客户端的输入已被接受，但客户端不应该改变任何UI元素

**205 Reset Content** 请求成功，但是报文不含实体主体部分，要求客户端重置内容

> 204和205的区别在于**205要求了重置**！
> 用一个表单为例，如果提交后返回204，那么表单里的各个字段值不变，可以继续修改它们；但假如得到的响应代码205，那么表单里的各个字段将被重置为它们的初始值。

206 Partial Content 进行范围请求

#### 3XX：重定向

**301 Moved Permanently**永久性重定向，资源已经被分配到了新的URL

**302 Found** 临时重定向，资源临时分配了URL 实际上发部分客户端把它当成303处理

**303 See Other** 表示资源存在另一个URL。应用Get获取资源

**307 Temporary Redirect** 临时重定向，资源临时分配了URL，但是希望客户端能够保持方法不变请求新地址（解决302被当成303处理的问题）

**304 Not Modified** 允许访问资源，但实体主体为空（客户端已经有此数据，不需要再次发送）

> 304需要特别说明一下，以免误解。
>
> 当用户第一次请求资源A时，服务器会添加一个名为`Last-Modified` 的响应头，这个头说明了A的 **最后修改时间** ，浏览器会把A的内容以及最后的响应时间缓存下来。
>
> 当用户第二次请求A时，在请求中包含一个名为`If-Modified-Since`请求头，它的值就是第一次请求时服务器通过`Last-Modified`响应头发送给浏览器的值，即资源A最后的修改时间。
>
> `If-Modified-Since`请求头就是在告诉浏览器，我这里浏览器缓存的A最后修改时间是这个，你看看现在A最后修改时间是不是这个，如果还是，那么就不用响应这个请求了，我会把缓存里的内容直接显示出来。
>
> 服务器会获取`If-Modified-Since`值，与A**当前的最后修改时间**作对比，如果相同，则服务器返回304状态码，表示A与浏览器上次缓存的相同，无需再次发送，浏览器可以显示自己的缓存页面，如果比对不同，那么说明A已经改变，服务器会返回200状态码。

**4XX：客户端错误**

**400 Bad Request**  请求报文语法错误

**401 Unauthorized**  发送的请求需要通过验证，客户端试图对一个受保护的资源操作但没有认证证书

**403 Forbidden**  请求资源存在但被拒绝，常用于一个资源只允许在特定时间段内访问（如果不想透露可以谎报404）

**404 Not Found** 找不到请求的资源

**405 Method Not Allowed**  不支持的请求方法，比如只支持Get，但是收到了Post请求

**5XX：服务端错误**

**500 Internal Server Error** 执行请求时发生错误（处理异常）

**501 Not Implemented**  不支持此请求方法（和405区别在于，405是访问的资源不支持，而501表示服务器不能操作此方法）

**502 Bad Gateway**  代理与上行服务器之间出现问题

**503 Service Unavailable** 服务器暂时处于超负荷或者维护中

### 2.3 Http协议中的长短连接和长短轮询

- 短连接

  所谓短连接，即连接只保持在数据传输过程，请求发起，请求建立，数据返回，连接关闭。它适用于一些实时数据请求，配合轮询来进行新旧数据的更替。

- 长连接

  长连接便是在连接发起后，在请求关闭连接前客户端与服务器都保持连接，实质是保持这个通信管道，之后便可以对其进行复用。

- 短轮询

  短轮询指的是在循环周期内，不断发起请求，每一次请求都立即返回结果，根据新旧数据对比决定是否使用这个结果。

- 长轮询

  长轮询是在请求的过程中，若是服务器端数据并没有更新，那么则将这个连接挂起，直到服务器推送新的数据，再返回，然后再进入循环周期。

##### 长短连接和长短轮询的区别

1. 决定方式。一个TCP连接是否为长连接，是通过设置HTTP的Connection Header来决定的，而且是需要两边都设置才有效。而一种轮询方式是否为长轮询，是根据服务器端的处理方式来决定的，与客户端没有关系。
2. 实现方式。连接的长短是通过协议来规定和实现的。而轮询的长短，是服务器通过编程的方式手动挂起请求来实现的。

### Http为什么不安全？

1. 数据以明文传递，有被窃听的风险
2. 接收到的报文无法证明是发送时的报文，不能保证完整性，因此报文有被篡改的风险
3. 不验证通信两端的身份，请求或响应有被伪造的风险

## 3 Https

### 3.1 TLS

https仍用http传输信息，但信息通过TLS进行了加密。

TLS作用于表示层

#### 两种加密技术

- 对称加密

  两边有相同的密钥，都知道如何加密解密

- 非对称加密

  数据公钥加密，私钥解密，私钥只有发出公钥的一方知道

对称加密问题在于如何让双方都知道密码，且不被其他人知道；非对称加密可以完美解决对称加密存在的问题

流程如下：

服务器将公钥发散出去。之后客户端创建一个密钥，用此公钥加密后发送给服务器，服务器用私钥解密，就能得知此密钥。双方都知道密码，之后就可以采用对称加密的方式进行数据传输了。

#### TSL的握手过程

原理讲完了，那么**TSL的握手过程**就很清晰了

![img](https://github.com/YiiChitty/FrontEndLearning/blob/master/img/http_01.png)

1.客户端发送一个随机值**ClientHello**，并附带上支持的协议和支持的加密方式

2.服务端收到随机值**ClientHello**，产生一个随机值**ServerHello**，根据客户端需求的协议返回，从客户端支持的堆成加密算法中选一个作为最终通讯的算法，并发送自己的CA证书

3.客户端收到服务器CA证书、协商的通讯加密算法、随机值**ServerHello**，验证通过后再生成第三个随机值**预主密钥Pre-Master**，用CA证书公钥加密后发送给服务端（如果需要验证证书，还要附带上证书）。
**用三个随机值+协商的加密算法，合成最终通讯的密钥** 。
change_cipher_spec Finished 客户端握手结束通知。

4.服务端收到加密过的随机值之后，**私钥** 解密获得第三个随机值**预主密钥Pre-Master** 。
**使用第1、2步中协商的对称加密算法+三个随机值合成最终的协商密钥** 。
change_cipher_spec Finished 服务器握手结束通知。

5.此时两端都有了最终的协商密钥了，接来下的传输就使用这个密钥加密解密。



所以，在**TLS 握手阶段，两端使用非对称加密的方式来通信** ，但是因为非对称加密损耗的性能比对称加密大，所以**在正式传输数据时，两端传输其实是使用对称加密的方式通信** 。



### 3.2 Https的缺点？

1. 通信两端都需要进行加密和解密，会**消耗** 大量的CPU、内存等**资源** ，**增加了服务器的负载**
2. 加密运算和多次握手**降低了访问速度**
3. 在开发阶段，**加大了页面调试难度** 。由于信息都被加密了，所以用代理工具的话，需要先解密然后才能看到真实信息
4. 用HTTPS访问的页面，页面内的外部资源都得用HTTPS请求，包括脚本中的AJAX请求

### 3.3 HTTPS 的单向认证和双向认证

**单向认证**

1. 客户端保存着服务器的证书并信任该证书
2. https一般是单向认证，这样可以让绝大部分人都可以访问你的站点

**双向认证**

1. 先决条件是有2个或者2个以上的证书，一个服务器证书，其它是客户端证书
2. 服务器保存着客户端的证书并信任该证书，客户端保存着服务器的证书并信任该证书。这样，在证书验证成功的情况下即可完成请求响应
3. 双向认证一般用于企业应用对接（比如说堡垒机hh）

## 5.回到面试的问题：http和https有什么区别？

1. HTTP是超文本传输协议，信息是**明文传输** ，HTTPS则是具有安全性的SSL加密传输协议
2. HTTP和HTTPS使用的是完全不同的连接方式，用的**端口也不一样，前者是80，后者是443**
3. HTTPS协议需要CA申请证书，一般免费证书比较少，因而需要一定费用
4. HTTP的连接很简单，是无状态的；HTTPS协议是由**TSL**协议进行了加密，比HTTP协议安全

请问需要补充说明TSL协议吗？

​	TSL协议两种加密方式 、原理 、握手过程

## 6. http版本(1.1 or 2.0 or 3.0)

### 6.1 http1.1有何不足？

1. 在传输中会出现队首阻塞问题(因为**浏览器限制了同一域名下的请求数量**，谷歌浏览器是6个连接，请求很多的时候只能等待其他完成再请求)
2. 响应不分轻重缓急，只会按先来后到的顺序执行
3. 并行通信需要建立多个TCP连接
4. 服务器不能主动推送客户端想要的资源，只能被动地等待客户端发起请求
5. 由于HTTP是无状态的，所以每次请求和响应都会携带大量冗余信息

### 6.2 http2.0

#### 新特性

1. **多路复用**

   通过一个TCP连接传输所有数据。一个请求对应一个id，这样一个链接上可以有多个请求，每个连接的请求可以随机的混杂在一起，接收方可以根据请求的id将请求再归属到各自不同的服务器端请求里面

2. **二进制分帧层**

   HTTP/2.0性能增强的关键，它改变了通信两端交互数据的方式，原先是以文本传输，现在要先对数据进行二进制编码，再把数据分成一个一个的帧，接着把帧送到数据流中，最后对方接受帧并拼接成一条消息，再处理请求

3. **首部压缩**

   前面提到过的HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小

4. **服务器推送**

   HTTP2.0支持服务器主动推送，简单地说就是一次请求返回多个响应，这也是一减少HTTP请求的方法。服务器除了处理最初的请求外，还会额外push客户端一定会请求的资源，无需客户端发出明确的请求。

#### http2.0的问题

http2.0使用了多路复用，一般来说同一域名下只需要使用一个TCP连接。
但是当连接中出现丢包时，整个TCP都要开始等待重传，后面的数据也都被阻塞了。而http1.0可以开启多个连接，只会影响一个，不会影响其他的。
所以**在丢包情况下，http2.0的情况反而不如http1.0**。

### 6.3 http3.0

为了解决2.0丢包性能的问题，Google基于UDP提出了QUIC协议。

HTTP3.0中的底层支撑协议就是QUIC。所以http3.0也叫HTTP-over-QUIC。

> **(¯﹃¯)想不到http居然也有“抛弃”好基友TCP的一天**

#### QUIC

UDP协议高效，但不可靠。QUIC基于UDP，在原来的基础上结合了tcp和http的精华使它可靠。

##### QUIC特性

**多路复用**

HTTP2虽然是多路复用，但是TCP协议是没有这个功能的。QUIC 原始就包含此功能，并且传输的单个数据流可以保证有序交付且不会影响其他数据流

其在移动端也会比TCP好，因为TCP基于IP+端口识别连接，不适合多变的网络环境，但是**QUIC是通过ID识别连接，不论网络如何变化，只要ID不变，就能迅速连上**（实时手游就是这样实现的）

**纠错机制**

假如说这次我要发送三个包，协议会算出这三个包的异或值并单独发出一个校验包，也就是总共发出了四个包。

当出现其中的非校验包丢包的情况时，可以通过另外三个包计算出丢失的数据包的内容。

当然这种技术只能使用在丢失一个包的情况下，如果出现丢失多个包就不能使用纠错机制了，只能使用重传的方式了。

**0-RTT**

通过使用类似 TCP 快速打开的技术，缓存当前会话的上下文，在下次恢复会话的时候，只需要将之前的缓存传递给服务端验证通过就可以进行传输了。

## 7 回到面试的问题上来：http1.0和http2.0的区别是什么？

http2.0是对http1.0的改进，相较于http1.0更快更高效

1http2.0实现了**多路复用**，用**一个TCP进行连接共享，一个请求对应一个id，这样就可以发送多个请求**，接收方通过id来响应不同的请求，解决了http1.0队首阻塞和连接过多的问题。因为http2.0**在同一域名不论访问多少文件都只有一个连接**，所以对服务器而言，提升的并发量是很大的。

2 http2.0引入了**二进制数据帧和流**的概念，**数据拆分成数据帧传输，并进行顺序标识，接收方收到数据后按序组合即可获取正确数据**。这样就可以**并行**传输了，解决了http1.0只能串行传输的问题。

3 http2.0**压缩头部**，使**用序号对头部编码，在两端备份索引表，通过对编码进行比较来判断是否需要传输，减少了需要传输的大小**。解决了http1.0中头部反复传输资源浪费的问题

4 http2.0中，服务器可以在客户端某个请求后，**主动推送一些客户端一定需要的资源** 。这样也能减少请求的数目。

当然http2.0也不是尽善尽美的，比如说在出现丢包的情况时，需要重新传输，后面的数据也就被阻塞了，但是http1.0因为有多个连接，所以不会影响其他连接的传输。这样的话http2.0的性能反倒不如http1.0了。

但这个是TCP的问题了，要说改TCP也不太实际。不过也有解决方案，基于QUIC协议的http3.0就解决了这个问题，需要简单描述一下吗？

​	QUIC的简单描述：多路复用（ID识别）、纠错机制

