# 性能优化

关于优化之前在浏览器渲染的部分也提到过了，可以去参考[看一下](https://github.com/YiiChitty/FrontEndLearning/blob/master/浏览器/浏览器渲染.md)。

这里说一下JS的性能优化，在说优化之前需要了解一下引擎是怎么解析的：



## 基于Chrome 的 **V8** 引擎

在V8引擎下，JS 代码首先会解析为抽象语法树（AST），然后会通过解释器或者编译器转化为 **Bytecode** 或者 **Machine Code**

![img](https://github.com/YiiChitty/FrontEndLearning/blob/master/img/Effective_01.jpg)

JS 会首先被解析为 AST，解析的过程其实是略慢的。代码越多，解析的过程也就耗费越长，这也是我们需要压缩代码的原因之一。

然后 **Ignition** 负责将 AST 转化为 Bytecode，**TurboFan** 负责编译出优化后的 Machine Code，并且 Machine Code 在执行效率上优于 Bytecode。



**问题来了，什么情况下代码会编译为MachineCode?**

JS 是一门**动态类型**的语言，并且还有一大堆的规则。简单的加法运算代码，内部就需要考虑好几种规则，比如数字相加、字符串相加、对象和字符串相加等等。这样的情况也就势必导致了内部要增加很多判断逻辑，降低运行效率。



如果一个函数被**多次调用**并且参数一直传入某个类型，那么 V8 就会认为该段代码可以编译为 Machine Code，因为你**固定了类型**，不需要再执行很多判断逻辑了。

举一个栗子：

```js
function example(x){
    return x+1;
}
for (let i=i;i<100;i++){
    example(i);
}
```

这种情况下，example被多次调用，并且参数一直是number类型。



但是如果一旦我们传入的参数**类型改变**，那么 Machine Code 就会被 **DeOptimized**为 Bytecode，这样就有性能上的一个损耗了。所以如果我们希望代码能多的编译为 Machine Code 并且 DeOptimized 的次数减少，就应该尽可能保证传入的**类型一致**。

另外，编译器还有个 **Lazy-Compile**，当函数没有被执行的时候，会对函数进行一次预解析，直到代码被执行以后才会被解析编译。

对于上述代码来说，example函数需要被预解析一次，然后在调用的时候再被解析编译。但是对于这种函数马上就被调用的情况来说，预解析这个过程其实是多余的，那么有什么办法能够让代码不被预解析呢？

其实很简单，我们只需要给函数**套上括号**就可以了

```js
(function example(obj) {
  return x + 1
})
```

但是我们不可能为了性能优化，给所有的函数都去套上括号。并且，也不是所有函数都需要这样做。



**小结一下**

通过对V8引擎的学习：

为了减少编译时间，可以采用**减少代码文件的大小**或者**减少书写嵌套函数**的方式；

同时，为了让引擎来优化代码，在使用js的时候，应该尽可能保证传入参数的**类型一致**

或许第二点也是使用 TypeScript 能够带来的好处之一



相关文章:

[JavaScript 引擎基础：Shapes 和 Inline Caches](https://hijiangtao.github.io/2018/06/17/Shapes-ICs/)

[WebAssembly 系列（二）JavaScript Just-in-time (JIT) 工作原理](https://www.w3ctech.com/topic/2026)



关于js优化就先说到这里，接下来是一些琐碎的点：



## 图片优化

### 计算图片大小

对于一张 100 * 100 像素的图片来说，图像上有 10000 个像素点，如果每个像素的值是 **RGBA** 存储的话，那么也就是说每个像素有 4 个通道，每个通道 1 个字节（8 位 = 1个字节），所以该图片大小大概为 39KB（10000 * 1 * 4 / 1024）。

但是在实际项目中，一张图片可能并不需要使用那么多颜色去显示，我们可以通过减少每个像素的调色板来相应缩小图片的大小。

如何优化图片：

- **减少像素点**
- **减少每个像素点能够显示的颜色**

### 图片加载优化

1. 不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用 CSS 去代替。
2. 对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。
3. 小图使用 base64 格式
4. 将多个图标文件整合到一张图片中（雪碧图）
5. 选择正确的图片格式：
   - 对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好
   - 小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替
   - 照片使用 JPEG



## DNS 预解析

DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP。

```html
<link rel="dns-prefetch" href="//www.xxxxx.com">
```



## 防抖与节流

这个在js部分写过了，可以直接[查看](https://github.com/YiiChitty/FrontEndLearning/blob/master/Javascript/防抖节流.md)。



## 预渲染

可以通过预渲染**将下载的文件预先在后台渲染**，可以使用以下代码开启预渲染

```html
<link rel="prerender" href="http://example.com"> 
```

预渲染虽然可以提高页面的加载速度，但是要**确保该页面大概率会被用户在之后打开**，否则就是白白浪费资源去渲染。



## 懒执行

懒执行就是**将某些逻辑延迟到使用时再计算**。

该技术可以用于首屏优化，对于某些耗时逻辑并不需要在首屏就使用的，就可以使用懒执行。

懒执行需要唤醒，一般可以通过定时器或者事件的调用来唤醒。



## 懒加载

懒加载就是**将不关键的资源延后加载**。

懒加载的原理就是只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西。

对于图片来说，先设置图片标签的 `src` 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为 `src` 属性，这样图片就会去下载资源，实现了图片懒加载。

懒加载不仅可以用于图片，也可以使用在别的资源上。比如进入可视区域才开始播放视频等等。



## CDN

CDN 的原理是尽可能的在各个地方分布机房缓存数据，这样即使我们的根服务器远在国外，在国内的用户也可以通过国内的机房迅速加载资源。

因此，我们可以将**静态资源尽量使用 CDN 加载**，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 CDN 域名。并且对于 CDN 加载静态资源需要注意**CDN 域名要与主站不同**，否则每次请求都会带上主站的 Cookie，平白消耗流量。

