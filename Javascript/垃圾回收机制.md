## 垃圾回收机制

V8将内存（堆）分为新生代和老生代两部分。

新生代对象一般存活时间短，其内存空间分为两个部分，From空间和To空间，在这两个空间中，有一个是使用的，一个是空闲的。新分配的对象放入From空间中，当Form占满时，新生代GC启动，检查Form对象存活对象复制到To空间，失活就销毁。复制完成后Form空间和To空间互换。

老生代对象一般存活时间长，数量多，用了两个算法：标记清楚算法和标记压缩法。当新生代对象已经经历过一次GC算法了，将对象放入老生代空间；或者To空间对象占比超过25%，为不影响内存分配，会将对象放入老生代空间。

当某个空间没有分块、空间中被对象超过一定限制、空间中不能保证新生代对象移动到老生代中，会启动标记清除的算法。遍历所有对象，标记活的对象，销毁未标记的。清除对象后会造成内存出现碎片的情况，超过一定限制启动压缩算法。将活的对象一端移动，直到所有对象都移动完成，清理掉不需要的内存。





时间不够，后面再来好好了解这一块的内容。

关于它的详解可以看这篇[文章](https://www.jianshu.com/p/455d0b9ef0a8)。

补充一下：

其实，标记有很多性能上的问题。为了解决这个问题，2011 年，V8 从 stop-the-world 标记切换到增量标志。在增量标记期间，GC 将标记工作分解为更小的模块，可以让 JS 应用逻辑在模块间隙执行一会，从而不至于让应用出现停顿情况。但在 2018 年，GC 技术又有了一个重大突破，这项技术名为并发标记。该技术可以让 GC 扫描和标记对象时，同时允许 JS 运行。具体的内容看V8的研究成果，戳[这个连接](https://v8project.blogspot.com/2018/06/concurrent-marking.html)。

